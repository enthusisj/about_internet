# HTTP(HyperText Transfer Protocol)란?   
-HTTP는 1989년부터 1991년에 발명되었다.   
-HTTP는 월드 와이드 웹(WWW)에 내재된 프로토콜이다.   
-HTTP는 인터넷에서 데이터를 주고 받을 수 있는 프로토콜이다.   
-웹 페이지를 방문할 때마다 컴퓨터는 HTTP(Hypertext Transfer Protocol)를 사용하여 인터넷 어딘가에 있는 다른 컴퓨터에서 해당 페이지를 다운로드한다.   
   

![logo](https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/09/HTTP-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF.png?resize=480%2C270&ssl=1)  


>## 프로토콜이란?   
통신 프로토콜 또는 통신 규약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다. 즉 **통신 규약 및 약속**이다.   
   
>>## 프로토콜의 기본 요소   
***구문(Syntax)*** : 전송하고자 하는 데이터의 형식(Format), 부호화(Coding), 신호 레벨(Signal Level) 등을 규정   
***의미(Semantics)*** : 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정   
***시간(Timing)*** : 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정   

>>## 프로토콜의 종류
HTTP, TCP, IP 등   

>>>## 프로토콜의 기능      
1. **단편화와 재합성**   
***단편화*** : 송신 측에서는 긴 데이터 블록을 손쉽게 전송할 수 있도록 크기가 똑같은 작은 블록으로 나누어 전송   
***재합성*** : 수신 측에서 쪼개진 작은 데이터 블록을 재합성하여 원래의 메시지로 복원하는 기능   

2. **캡슐화**   
각 프로토콜에 적합한 데이터 블록을 만들려고 데이터에 정보를 추가하는 것   
플래그, 주소, 제어 정보, 오류 검출 부호 등을 부착하는 기능

3. **연결 제어**   
비연결 데이터 전송(데이터그램)과 연결 위주 데이터 전송(가상회선)을 위한 통신로를 개설·유지·종결하는 기능   

4. **흐름 제어**   
데이터양이나 통신속도 등이 수신 측의 처리 능력을 초과하지 않도록 조정하는 기능   

5. **오류 제어**
데이터 전송 중 발생할 수 있는 오류나 착오 등을 검출하고 정정하는 기능   

6. **순서 결정**   
연결 위주의 데이터를 전송할 때 송신 측이 보내는 데이터 단위 순서대로 수신 측에 전달하는 기능    


7. **주소 설정**   
발생지, 목적지 등의 주소를 명기하여 데이터를 정확하게 전달하는 기능   
   
8. **동기화**   
두 통신 객체의 상태(시작, 종류, 검사 등)를 일치시키는 기능   

9. **다중화**   
하나의 통신로를 여러 개로 나누거나 회선 여러 개를 하나의 통신로로 변환시켜 다수의 가입자가 동시에 사할 수 있도록 하는 기능   

10. **전송 서비스**   
통신 객체를 사용하기 쉽도록 별도로 추가 서비스(패리티 검사, 보안도, 서비스 등급, 우선순위 등)를 제공하는 기능   

---------------------------------------------
# HTTP 동작
클라이언트 즉, 사용자가 브라우저를 통해서 어떠한 서비스를 url을 통하거나 다른 것을 통해서 요청(request)을 하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 응답(response)하는 형태로 동작한다.   
> 요청 : client -> server   
응답 : server -> client
   
### URL
**URL(Uniform Resource Locator)**은 인터넷에서 웹 페이지, 이미지, 비디오 등 리소스의 위치를 가리키는 문자열이다.

***HTTP*** 맥락에서 URL은 "웹 주소" 또는 "링크"라고 불린다.    
***브라우저***는 https://developer.mozilla.org 등 URL을 주소창에 표시합니다.    
*일부 브라우저*는 URL에서 "//" 뒤의 일부분, 즉 도메인 이름만 표시합니다.

-------------------------------------------------------
# HTTP 특징   
***-클라이언트 서버 구조   
-무상태 프로토콜(Stateless)   
-비 연결성(Connectionless)   
-HTTP 메세지 
-단순함, 확장 가능 

**1. 클라이언트 서버 구조**
> 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조로 이루어져 있다.   

* Request Response 구조
* 클라이언트는 서버에 요청을 보내고 응답을 대기
* 서버가 요청에 대한 결과를 만들어 응답
   
![logo](https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/09/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3-%E1%84%89%E1%85%A5%E1%84%87%E1%85%A5.png?resize=768%2C311&ssl=1)   

**2.무상태 프로토콜-Stateless**
>HTTP에서 서버가 클라이언트의 상태를 보존하지 않는 무상태 프로토콜이다.   
예를 들어, 클라이언트가 서버에게 “저녁에 치킨먹자”고 말했고 서버가 “그래”라고 답했다.   
저녁이 되어 클라이언트는 서버에게 “먹으러 가자”고 말했고 서버는 대답했다. “뭘?”   
   
* 서버가 클라이언트 상태를 보존하지 않음
* 장점 : 서버 확장성 높음 (스케일 아웃)
* 단점 : 클라이언트가 추가 데이터 전송

![logo](https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/09/HTTP-%E1%84%86%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%E1%84%89%E1%85%A5%E1%86%BC.png?w=689&ssl=1)   


그렇다면, 상태와 무상태를 비교해보면?  
## Stateful(상태 유지) vs Stateless(무상태)   
카페에서 카페라떼 2잔을 신용카드로 결제한다고 가정한다.   

***상태 유지(Stateful)***   
* 상태가 유지되는 때에는 점원 A가 고객의 주문 상태에 대해 기억하고 있다.   
-고객 : 카페라떼 얼마인가요?   
-점원A : 5천원입니다. (여기서 카페라떼 상태 유지)   
-고객 : 2잔 주세요.   
-점원A : 만원입니다. 어떤걸로 결제하시겠어요? (여기서 카페라떼, 2잔 상태 유지)   
-고객 : 신용카드 결제할게요.   
-점원A : 만원 결제 완료 되었습니다. (여기서 카페라떼, 2잔, 신용카드 상태 유지)   

***상태 유지(Stateful) – 점원이 중간에 바뀌면?***   
* 만약 중간에 점원A가 아닌 점원B가 그대로 고객을 응대한다고 가정한다.   
이 경우 점원A만 고객의 주문을 기억하고 있기 때문에 상태정보를 다른 점원B에게 미리 알려줘야 한다.   
미리 알려주지 않을 시 아래와 같은 사태가 발생한다.   
-고객 : 카페라떼 얼마인가요?   
-점원A : 5천원입니다.   
-고객 : 2잔 주세요.   
-점원B : ?? 어떤 음료 2잔 결제하십니까?   
-고객 : 신용카드로 결제할게요.   
-점원B : ?? 어떤 음료를 신용카드로 몇 잔 결제하십니까?   

> 이렇게 점원A가 고객의 상태를 기억하고 있는 것을 **상태 유지**라고 한다.   

***무상태(Stateless)***   
* 무상태에서는 고객이 자신의 주문을 기억하고 있다면 중간에 다른 점원으로 바뀌어도 주문을 할 수 있다.   
만약 갑자기 고객이 증가하더라도 무상태에서는 점원을 대거 투입할 수 있다.   
-고객 : 카페라떼 얼마인가요?   
-점원A : 5천원입니다.   
-고객 : 2잔 주세요.   
-점원B : 만원입니다. 어떤걸로 결제하십니까?   
-고객 : 신용카드 결제할게요.   
-점원C : 만원 결제 완료 되었습니다.   

***상태 유지와 무상태 정리***   
**상태 유지** : 중간에 다른 점원으로 바뀌면 안된다.
중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야한다.   
**무상태** : 중간에 다른 점원으로 바뀌어도 된다.
갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.   
갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.   
*무상태는 응답 서버를 쉽게 바꿀 수 있다. —> 무한한 서버 증설 가능*

## 상태 유지
* 항상 같은 서버가 유지 되어야한다.  
-상태 유지가 되어야하는 프로토콜이라면 클라이언트A의 요청을 서버1이 기억하고 있기 때문에 항상 서버1이 응답해야한다.
* 만약에 서버에 장애가 생긴다면?   
-만약 서버1이 장애가 난다면 유지되던 상태정보가 다 날아가버리므로 처음부터 다시 서버에 요청해야 한다.   

## 무상태   
* 아무 서버나 호출해도 된다.   
-무상태 프로토콜이라면 클라이언트A가 요청할 때 이미 필요한 데이터를 다 담아서 보내기 때문에 아무 서버나 호출해도 된다.
* 만약에 서버에 장애가 생긴다면?   
-만약 서버1에 장애가 생기도라도 다른 서버에서 응답을 전달하면 되기 때문에 클라이언트는 다시 요청할 필요가 없다.
* 스케일 아웃- 수평 확장 유리   
-무상태는 응답 서버를 쉽게 바꿀 수 있기 때문에 무한한 서버 증설이 가능하다.
* 실무에서의 한계   
-모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다.   
-무상태 : 로그인이 필요없는 단순한 서비스 소개 화면   
-상태 유지 : 로그인   
-로그인한 사용자의 경우 로그인했다는 생태를 서버에 유지(브라우저 쿠키, 서버 세션, 토큰 등)   
-상태 유지는 *최소한*만 사용

**3. 비연결성**   
* HTTP는 기본이 연결을 유지하지 **않는** 모델   
    -HTTP 1.0 기준으로 HTTP는 연결을 유지하지 않는 모델이다.   
* 일반적으로 초 단위 이하의 빠른 속도로 응답   
    -트래픽이 많지 않고, 빠른 응답을 제공할 수 있는 경우에 비 연결성의 특징은 효율적으로 작동한다.   
    -1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십 개로 매우 작음.   
    -예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다.
트래픽이 많고 큰 규모의 서비스를 운영할 때는 비 연결성은 한계를 보인다.  

## 연결성 vs 비연결성   
👉**연결 지향(Connection Oriented)**  –연결을 유지하는 모델   
-TCP/IP의 경우 기본적으로 연결을 유지한다.  
-연결을 유지하는 모델에서는 클라이언트가 요청을 보내지 않더라도 계속 연결을 유지해야 한다.   
-이러한 경우 연결을 유지하는 서버의 자원이 계속 소모된다.  
👉**비 연결성(Connectionless)**   – 연결을 유지하지 않는 모델   
-비 연결성을 가지는 HTTP에서는 실제로 요청을 주고 받을 때만 연결을 유지하고 응답을 주고나면 TCP/IP 연결을 끊는다.  
-이를 통해 최소한의 자원으로 서버 유지를 가능하게 한다.   

## 비 연결성 한계와 극복
* 비 연결성은 다음과 같은 한계를 가진다.   
-TCP/IP 연결을 새로 맺어야 함 – 3 way handshake 시간 추가   
-웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JavaScript, CSS, 추가 이미지 등 수 많은 자원이 함께 다운로드 된다.   
* 해당 자원들을 각각 보낼때마다 연결끊고 다시 연결하고를 반복하는 것은 비효율적이기 때문에 지금은 HTTP 지속 연결로 문제를 해결한다.   
* HTTP/2, HTTP/3에서 더 많은 최적화   
   

## 비 연결성 극복 – HTTP 지속 연결(Persistent Connections)
* HTTP 초기 – 연결, 종료 낭비   
-HTTP 초기에는 각각의 자원을 다운로드하기 위해 연결과 종료를 반복해야 했다.
* HTTP 지속 연결 (Persistent Connections)   
-HTTP 지속 연결에서는 연결이 이루어지고 난 뒤 각각의 자원들을 요청하고 모든 자원에 대한 응답이 돌아온 후에 연결을 종료한다.

---------------------------
## HTTP의 예시
* 서버: 어떠한 자료에 대한 접근을 관리하는 네트워크 상의 시스템   
(요청에 대한 응답을 보내준다.)
* 클라이언트: 그 자료에 접근할 수 있는 프로그램    
ex)웹 브라우저, 핸드폰 어플리케이션 등...

클라이언트 프로그램에서 사용자가 회원가입을 시도하게 되면, 서버로 회원정보를 보내게 되고 서버는 회원 정보를 저장해주기도 한다. 이 과정에서 클라이언트와 서버 간의 교류가 HTTP라는 규약을 이용하여 발생하게 된다.

-------------------------------
## 링크
* 참조링크   
[google](https://velog.io/@surim014/HTTP%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)
